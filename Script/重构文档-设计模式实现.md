# Unity RPG 项目重构 - 设计模式实现文档

## 概述

本文档详细记录了本次重构中实现的**六个核心设计模式**，包括每个模式的目的、实现位置和具体代码修改。

---

## 一、Service Locator Pattern（服务定位器模式）

### 模式类型
**额外模式**（未在课程中讲授，但作为架构基础）

### 目的
提供统一的服务注册和查找机制，替代静态单例模式，实现依赖解耦。

### 实现位置

#### 1. 核心服务定位器
**文件：** `Core/ServiceLocator.cs`  
**行号：** 1-93  
**关键代码：**
```csharp
// 第15-28行：单例实例
public static ServiceLocator Instance { get; }

// 第35-50行：注册服务
public void RegisterSingleton<T>(T service, bool overwrite = false)

// 第57-70行：获取服务
public T Get<T>()

// 第77-81行：清空服务
public void Clear()

// 第88-93行：重置服务定位器
public static void Reset()
```

#### 2. 服务注册入口
**文件：** `Core/GameBootstrap.cs`  
**行号：** 32-120  
**关键代码：**
```csharp
// 第35行：重置服务定位器（场景切换时）
ServiceLocator.Reset();

// 第84-120行：注册所有核心服务
private void RegisterCoreServices()
{
    // 第88-89行：注册音频管理器
    ServiceLocator.Instance.RegisterSingleton<IAudioManager>(audioManager);
    
    // 第92-93行：注册游戏管理器
    ServiceLocator.Instance.RegisterSingleton<IGameManager>(gameManager);
    
    // 第96-97行：注册玩家管理器
    ServiceLocator.Instance.RegisterSingleton<IPlayerManager>(playerManager);
    
    // 第100-101行：注册物品栏
    ServiceLocator.Instance.RegisterSingleton<IInventory>(inventory);
    
    // 第104-105行：注册技能管理器
    ServiceLocator.Instance.RegisterSingleton<ISkillManager>(skillManager);
    
    // 第108-109行：注册存档管理器
    ServiceLocator.Instance.RegisterSingleton<ISaveManagerService>(saveManager);
    
    // 第112-113行：注册掉落物管理器
    ServiceLocator.Instance.RegisterSingleton<IDroppedItemManager>(droppedItemManager);
    
    // 第116行：注册事件总线
    ServiceLocator.Instance.RegisterSingleton<GameEventBus>(new GameEventBus());
}
```

#### 3. 服务接口定义
**文件位置：** `Core/Interfaces/`  
- `IAudioManager.cs` - 音频管理器接口
- `IGameManager.cs` - 游戏管理器接口
- `IPlayerManager.cs` - 玩家管理器接口
- `IInventory.cs` - 物品栏接口
- `ISkillManager.cs` - 技能管理器接口
- `ISaveManagerService.cs` - 存档服务接口
- `IDroppedItemManager.cs` - 掉落物管理器接口

### 使用示例
**文件：** `UI/UI_InGame.cs`  
**行号：** 60-61  
```csharp
playerManager = ServiceLocator.Instance.Get<IPlayerManager>();
skills = ServiceLocator.Instance.Get<ISkillManager>();
inventory = ServiceLocator.Instance.Get<IInventory>();
```

---

## 二、Factory Method Pattern（工厂方法模式）

### 模式类型
**创建型模式**

### 目的
为敌人状态创建提供统一的工厂接口，让子类决定实例化哪些状态对象，实现状态创建的解耦。

### 实现位置

#### 1. 工厂接口
**文件：** `Enemy/Factories/IEnemyStateFactory.cs`  
**行号：** 1-10  
```csharp
public interface IEnemyStateFactory<TStates> where TStates : IEnemyStates
{
    TStates CreateStates(Enemy enemy, EnemyStateMachine stateMachine);
}
```

**文件：** `Enemy/Factories/IEnemyStates.cs`  
**行号：** 1-5  
```csharp
public interface IEnemyStates
{
    EnemyState InitialState { get; }
}
```

#### 2. 具体工厂实现

**Skeleton 工厂：** `Enemy/Skeleton/SkeletonStateFactory.cs`  
**行号：** 1-21  
```csharp
// 第3行：实现工厂接口
public class SkeletonStateFactory : IEnemyStateFactory<SkeletonStates>
{
    // 第5-18行：创建 Skeleton 状态集合
    public SkeletonStates CreateStates(Enemy enemy, EnemyStateMachine stateMachine)
    {
        // 创建所有 Skeleton 状态
        return new SkeletonStates(...);
    }
}
```

**Slime 工厂：** `Enemy/Slime/SlimeStateFactory.cs`  
**行号：** 1-18  
```csharp
public class SlimeStateFactory : IEnemyStateFactory<SlimeStates>
{
    public SlimeStates CreateStates(Enemy enemy, EnemyStateMachine stateMachine)
    {
        // 创建所有 Slime 状态
        return new SlimeStates(...);
    }
}
```

**NightBorn 工厂：** `Enemy/NightBorn/NightBornStatesFactory.cs`  
**行号：** 1-21  
```csharp
public class NightBornStatesFactory : IEnemyStateFactory<NightBornStates>
{
    public NightBornStates CreateStates(Enemy enemy, EnemyStateMachine stateMachine)
    {
        // 创建所有 NightBorn 状态
        return new NightBornStates(...);
    }
}
```

#### 3. 状态集合类

**Skeleton 状态集合：** `Enemy/Skeleton/SkeletonStates.cs`  
**行号：** 1-34  
```csharp
// 第3行：实现状态集合接口
public class SkeletonStates : IEnemyStates
{
    // 第5-12行：所有状态属性
    public SkeletonIdleState Idle { get; }
    public SkeletonMoveState Move { get; }
    // ...
    
    // 第22行：初始状态
    public EnemyState InitialState => Idle;
}
```

**Slime 状态集合：** `Enemy/Slime/SlimeStates.cs`  
**行号：** 1-24

**NightBorn 状态集合：** `Enemy/NightBorn/NightBornStates.cs`  
**行号：** 1-30

#### 4. 敌人类使用工厂

**Skeleton 敌人：** `Enemy/Skeleton/Enemy_Skeleton.cs`  
**行号：** 18-31  
```csharp
// 第22行：使用工厂创建状态
skeletonStates = new SkeletonStateFactory().CreateStates(this, stateMachine);

// 第24-30行：从状态集合获取各个状态
idleState = skeletonStates.Idle;
moveState = skeletonStates.Move;
// ...
```

**Slime 敌人：** `Enemy/Slime/Enemy_Slime.cs`  
**行号：** 25-34  
```csharp
// 第29行：使用工厂创建状态
slimeStates = new SlimeStateFactory().CreateStates(this, stateMachine);
```

**NightBorn 敌人：** `Enemy/NightBorn/Enemy_NightBorn.cs`  
**行号：** 18-31

---

## 三、Observer Pattern（观察者模式）

### 模式类型
**行为型模式**

### 目的
实现技能和装备系统与 UI 的解耦，通过事件总线实现发布-订阅机制。

### 实现位置

#### 1. 事件总线（Subject）
**文件：** `Core/Events/GameEventBus.cs`  
**行号：** 1-62  
**关键代码：**
```csharp
// 第13行：订阅者字典
private Dictionary<Type, List<Delegate>> subscribers;

// 第20-30行：订阅事件（注册观察者）
public void Subscribe<T>(Action<T> callback) where T : IGameEvent

// 第37-43行：取消订阅（移除观察者）
public void Unsubscribe<T>(Action<T> callback) where T : IGameEvent

// 第50-61行：发布事件（通知观察者）
public void Publish<T>(T gameEvent) where T : IGameEvent
```

#### 2. 事件定义

**技能事件：** `Core/Events/SkillEvents.cs`  
**行号：** 1-25  
```csharp
// 第5-11行：技能使用事件
public class SkillUsedEvent : IGameEvent
{
    public string EventName => "SkillUsed";
    public string SkillName { get; set; }
    public float Cooldown { get; set; }
}

// 第18-24行：技能解锁事件
public class SkillUnlockedEvent : IGameEvent
{
    public string EventName => "SkillUnlocked";
    public string SkillName { get; set; }
}
```

**装备事件：** `Core/Events/EquipmentEvents.cs`  
**行号：** 1-30  
```csharp
// 第5-13行：装备变更事件
public class EquipmentChangedEvent : IGameEvent
{
    public EquipmentType EquipmentType { get; set; }
    public ItemData_Equipment Equipment { get; set; }
    public bool IsEquipped { get; set; }
}

// 第20-25行：装备使用事件
public class EquipmentUsedEvent : IGameEvent
{
    public EquipmentType EquipmentType { get; set; }
}
```

#### 3. 事件发布（发布者）

**技能类发布事件：**

**Dash 技能：** `Skills/Dash_Skill.cs`  
**行号：** 约 80-120（UseSkill 方法）  
```csharp
// 发布技能使用事件
eventBus?.Publish(new SkillUsedEvent 
{ 
    SkillName = "Dash", 
    Cooldown = cooldown 
});

// 发布技能解锁事件
eventBus?.Publish(new SkillUnlockedEvent { SkillName = "Dash" });
```

**其他技能类：**
- `Skills/Crystal_Skill.cs` - 发布 Crystal 技能事件
- `Skills/Assassinate_Skill.cs` - 发布 Assassinate 技能事件
- `Skills/Blackhole_Skill.cs` - 发布 Blackhole 技能事件
- `Skills/Parry_Skill.cs` - 发布 Parry 技能事件
- `Skills/DashAttack_Skill.cs` - 发布 DashAttack 技能事件

**玩家状态发布事件：**

**PlayerDashState：** `Player/State/PlayerDashState.cs`  
**行号：** 约 40-50（Exit 方法）  
```csharp
eventBus?.Publish(new SkillUsedEvent 
{ 
    SkillName = "CloneOnDash", 
    Cooldown = player.skill.Clone.cooldown 
});
```

**PlayerCounterAttackState：** `Player/State/PlayerCounterAttackState.cs`  
**行号：** 约 20-30（Enter 方法）  
```csharp
eventBus?.Publish(new SkillUsedEvent 
{ 
    SkillName = "Parry", 
    Cooldown = player.skill.Parry.cooldown 
});
```

**Inventory 发布事件：** `Item/Inventory.cs`  
**行号：** 约 178-250  
```csharp
// EquipItem 方法中（约第200行）
eventBus?.Publish(new EquipmentChangedEvent
{
    EquipmentType = newEquipment.equipmentType,
    Equipment = newEquipment,
    IsEquipped = true
});

// CanUseWeapon/CanUseArmor/CanUseAmulet/CanUseFlask 方法中
eventBus?.Publish(new EquipmentUsedEvent 
{ 
    EquipmentType = EquipmentType.Weapon 
});
```

#### 4. 事件订阅（观察者）

**UI_InGame 订阅事件：** `UI/UI_InGame.cs`  
**行号：** 约 200-350  

**订阅方法（约第250行）：**
```csharp
private void SubscribeToEvents()
{
    // 订阅技能使用事件
    eventBus.Subscribe<SkillUsedEvent>(OnSkillUsedViaEventBus);
    
    // 订阅技能解锁事件
    eventBus.Subscribe<SkillUnlockedEvent>(OnSkillUnlockedViaEventBus);
    
    // 订阅装备变更事件
    eventBus.Subscribe<EquipmentChangedEvent>(OnEquipmentChangedViaEventBus);
    
    // 订阅装备使用事件
    eventBus.Subscribe<EquipmentUsedEvent>(OnEquipmentUsedViaEventBus);
}
```

**事件处理方法（约第280-400行）：**
```csharp
// 处理技能使用事件
private void OnSkillUsedViaEventBus(SkillUsedEvent evt)
{
    switch (evt.SkillName)
    {
        case "Dash": UseDash(evt.Cooldown); break;
        case "Crystal": UseCrystal(evt.Cooldown); break;
        // ...
    }
}

// 处理装备变更事件
private void OnEquipmentChangedViaEventBus(EquipmentChangedEvent evt)
{
    if (evt.IsEquipped)
        EquipXxx(evt.EquipmentType, evt.Equipment);
    else
        UnequipXxx(evt.EquipmentType);
}
```

**取消订阅（OnDestroy 方法，约第450行）：**
```csharp
private void OnDestroy()
{
    eventBus?.Unsubscribe<SkillUsedEvent>(OnSkillUsedViaEventBus);
    eventBus?.Unsubscribe<SkillUnlockedEvent>(OnSkillUnlockedViaEventBus);
    eventBus?.Unsubscribe<EquipmentChangedEvent>(OnEquipmentChangedViaEventBus);
    eventBus?.Unsubscribe<EquipmentUsedEvent>(OnEquipmentUsedViaEventBus);
}
```

---

## 四、Command Pattern（命令模式）

### 模式类型
**行为型模式**

### 目的
将技能输入封装为命令对象，实现输入与执行的解耦，支持命令的统一管理和扩展。

### 实现位置

#### 1. 命令接口
**文件：** `Skills/Commands/ISkillCommand.cs`  
**行号：** 1-8  
```csharp
public interface ISkillCommand
{
    void Execute();
}
```

#### 2. 具体命令实现

**Dash 命令：** `Skills/Commands/DashCommand.cs`  
**行号：** 1-60  
```csharp
// 第5行：实现命令接口
public class DashCommand : ISkillCommand
{
    // 第30-60行：Execute 方法封装 Dash 技能逻辑
    public void Execute()
    {
        if (player.stats.isDead) return;
        if (!skillManager.Dash.dash) return;
        if (skillManager.Dash.CanUseSkill())
        {
            // 执行 Dash 技能
            player.stateMachine.ChangeState(player.dashState);
        }
    }
}
```

**Crystal 命令：** `Skills/Commands/CrystalCommand.cs`  
**行号：** 1-25

**Flask 命令：** `Skills/Commands/FlaskCommand.cs`  
**行号：** 1-40

**Assassinate 命令：** `Skills/Commands/AssassinateCommand.cs`  
**行号：** 1-35

#### 3. 命令调用者（Invoker）

**PlayerInputHandler：** `Player/PlayerInputHandler.cs`  
**行号：** 1-150  

**命令绑定（约第30-80行）：**
```csharp
// 命令字段
private DashCommand dashCommand;
private CrystalCommand crystalCommand;
private FlaskCommand flaskCommand;
private AssassinateCommand assassinateCommand;

// 绑定命令方法
public void SetDashCommand(DashCommand command) => dashCommand = command;
public void SetCrystalCommand(CrystalCommand command) => crystalCommand = command;
// ...
```

**输入处理（约第90-150行）：**
```csharp
public void HandleInput()
{
    if (Input.GetKeyDown(KeyCode.LeftShift))
        dashCommand?.Execute();
    
    if (Input.GetKeyDown(KeyCode.E))
        crystalCommand?.Execute();
    
    if (Input.GetKeyDown(KeyCode.Alpha1))
        flaskCommand?.Execute();
    
    if (Input.GetKeyDown(KeyCode.R))
        assassinateCommand?.Execute();
}
```

#### 4. 客户端使用

**Player 类：** `Player/Player.cs`  
**行号：** 约 50-100  

**初始化命令（约第60行）：**
```csharp
private void InitializeCommands()
{
    inputHandler = new PlayerInputHandler();
    
    // 创建命令对象
    var dashCmd = new DashCommand(player, skillManager, inventory);
    var crystalCmd = new CrystalCommand(skillManager);
    var flaskCmd = new FlaskCommand(inventory, transform);
    var assassinateCmd = new AssassinateCommand(player, skillManager);
    
    // 绑定命令
    inputHandler.SetDashCommand(dashCmd);
    inputHandler.SetCrystalCommand(crystalCmd);
    inputHandler.SetFlaskCommand(flaskCmd);
    inputHandler.SetAssassinateCommand(assassinateCmd);
}
```

**Update 方法（约第120行）：**
```csharp
private void Update()
{
    // 使用命令模式处理输入
    inputHandler?.HandleInput();
}
```

---

## 五、Facade Pattern（外观模式）

### 模式类型
**结构型模式**

### 目的
为复杂的服务定位器子系统提供统一的简化接口，隐藏 ServiceLocator 的复杂性。

### 实现位置

**文件：** `Core/GameFacade.cs`  
**行号：** 1-251  

**关键代码：**

**单例实现（第33-60行）：**
```csharp
private static GameFacade instance;

public static GameFacade Instance
{
    get
    {
        if (instance == null)
            instance = new GameFacade();
        return instance;
    }
}
```

**服务属性（第70-100行）：**
```csharp
// 通过 ServiceLocator 获取服务，提供简化访问
public IPlayerManager Player => playerManager ??= ServiceLocator.Instance.Get<IPlayerManager>();
public ISkillManager Skills => skillManager ??= ServiceLocator.Instance.Get<ISkillManager>();
public IInventory Inventory => inventory ??= ServiceLocator.Instance.Get<IInventory>();
public IAudioManager Audio => audioManager ??= ServiceLocator.Instance.Get<IAudioManager>();
public IGameManager Game => gameManager ??= ServiceLocator.Instance.Get<IGameManager>();
public ISaveManagerService Save => saveManager ??= ServiceLocator.Instance.Get<ISaveManagerService>();
public IDroppedItemManager DroppedItems => droppedItemManager ??= ServiceLocator.Instance.Get<IDroppedItemManager>();
public GameEventBus Events => eventBus ??= ServiceLocator.Instance.Get<GameEventBus>();
```

**简化方法（第110-200行）：**
```csharp
// 音频方法
public void PlaySFX(int index) => Audio?.PlaySFX(index);
public void PlayBGM(int index) => Audio?.PlayBGM(index);
public void StopBGM() => Audio?.StopBGM();

// 游戏控制方法
public void PauseGame(bool pause) => Game?.PauseGame(pause);
public void RestartScene() => Game?.RestartScene();

// 玩家方法
public bool HaveEnoughMoney(int price) => Player != null && Player.Currency >= price;
public void AddCurrency(int amount) => Player.Currency += amount;
public void SpendCurrency(int amount) => Player.Currency -= amount;
```

**使用示例：**

**UI.cs：** `UI/UI.cs`  
**行号：** 17, 45, 46, 52, 53  
```csharp
// 第17行：使用 Facade
private GameFacade game => GameFacade.Instance;

// 第45行：简化访问
game.PlaySFX(23);

// 第46行：简化访问
game.PauseGame(true);
```

**UI_MainMenu.cs：** `UI/UI_MainMenu.cs`  
**行号：** 14, 18, 21, 26, 32, 39  
```csharp
private GameFacade game => GameFacade.Instance;

if (!game.Save.HaveSaveData())  // 第18行
    continueButton.SetActive(false);

game.PlayBGM(0);  // 第21行
```

---

## 六、Bridge Pattern（桥接模式）

### 模式类型
**结构型模式**

### 目的
将装备（抽象）与效果（实现）分离，使它们可以独立变化和扩展。

### 实现位置

#### 1. 抽象部分（Abstraction）
**文件：** `Item/ItemData_Equipment.cs`  
**行号：** 1-190  

**关键代码：**

**桥接注释（第12-17行）：**
```csharp
// ========== Bridge Pattern (Abstraction) ==========
// 装备系统采用桥接模式，将装备和效果分离
// - 装备类型（Weapon, Armor等）可以独立变化
// - 效果实现（Fire, Heal等）可以独立变化
// - 通过 itemEffects[] 桥接，灵活组合
```

**效果引用（第33行）：**
```csharp
// 桥接：持有效果引用，而不是继承
public ItemEffect[] itemEffects;
```

**执行效果（第79-123行）：**
```csharp
public void ExecuteItemEffect(Transform position)
{
    // 通过桥接调用效果实现
    foreach (var item in itemEffects)
    {
        if (item.ExecuteEffect(position))
            effectExecuted = true;
    }
    
    if (effectExecuted)
    {
        // 处理冷却时间等
    }
}
```

#### 2. 实现者接口（Implementor）
**文件：** `Item/Effect/ItemEffect.cs`  
**行号：** 1-33  

**关键代码：**
```csharp
// ========== Bridge Pattern (Implementor) ==========
// 定义所有具体物品效果必须实现的操作
[CreateAssetMenu(fileName = "New Item Data", menuName = "Data/Item effect")]
public class ItemEffect : ScriptableObject
{
    // 第12行：效果执行接口
    public virtual bool ExecuteEffect(Transform position) { return false; }
}
```

#### 3. 具体实现（ConcreteImplementor）

**火焰效果：** `Item/Effect/Fire_Effect.cs`  
**行号：** 1-40  
```csharp
// ========== Bridge Pattern (ConcreteImplementor) ==========
[CreateAssetMenu(fileName = "Fire effect", menuName = "Data/Item effect/Fire Effect")]
public class Fire_Effect : ItemEffect
{
    // 第15-30行：实现火焰效果逻辑
    public override bool ExecuteEffect(Transform position)
    {
        // 创建火焰特效
        // ...
    }
}
```

**治疗效果：** `Item/Effect/Heal_Effect.cs`  
**行号：** 1-27

**Buff 效果：** `Item/Effect/Buff_Effect.cs`  
**行号：** 1-66

**飞行效果：** `Item/Effect/Fly_Effect.cs`  
**行号：** 1-43

### 模式优势
- **独立扩展**：新增装备类型不影响效果实现
- **灵活组合**：任意装备可以组合任意效果
- **避免类爆炸**：无需为每种装备-效果组合创建新类

---

## 七、Composite Pattern（组合模式）

### 模式类型
**结构型模式**

### 目的
将 UI 元素组合成树形结构，统一管理单个元素和元素组，提供一致的显示/隐藏接口。

### 实现位置

#### 1. 组件接口（Component）
**文件：** `UI/Composite/IUIComponent.cs`  
**行号：** 1-39  
```csharp
// ========== Composite Pattern (Component) ==========
public interface IUIComponent
{
    void Show();
    void Hide();
    bool IsActive();
}
```

#### 2. 叶子节点（Leaf）

**UI 元素组件：** `UI/Composite/UIElementComponent.cs`  
**行号：** 1-38  
```csharp
// ========== Composite Pattern (Leaf) ==========
public class UIElementComponent : IUIComponent
{
    private GameObject uiElement;
    
    public void Show() => uiElement?.SetActive(true);
    public void Hide() => uiElement?.SetActive(false);
    public bool IsActive() => uiElement != null && uiElement.activeSelf;
}
```

**Tooltip 组件：** `UI/Composite/TooltipComponent.cs`  
**行号：** 1-51  
```csharp
// ========== Composite Pattern (Leaf) ==========
public class TooltipComponent : IUIComponent
{
    private MonoBehaviour tooltip;
    
    public void Hide()
    {
        // 根据不同的 Tooltip 类型调用对应的 Hide 方法
        if (tooltip is UI_ItemToolTip itemToolTip)
            itemToolTip.HideToolTip();
        // ...
    }
}
```

**淡入淡出组件：** `UI/Composite/FadeComponent.cs`  
**行号：** 1-61  
```csharp
// ========== Composite Pattern (Leaf) ==========
public class FadeComponent : IUIComponent
{
    private UI_FadeOut fadeOutComponent;
    private GameObject fadeGameObject;
    private bool hasFadedIn = false;
    
    // 第27-38行：Show 方法（触发淡入动画，只在首次调用时生效）
    public void Show()
    {
        if (fadeOutComponent == null || hasFadedIn)
            return;
        
        if (fadeGameObject != null && !fadeGameObject.activeSelf)
            fadeGameObject.SetActive(true);
        
        fadeOutComponent?.FadeIn();
        hasFadedIn = true;
    }
    
    // 第43-50行：Hide 方法（触发淡出动画并重置状态）
    public void Hide()
    {
        fadeOutComponent?.FadeOut();
        hasFadedIn = false;  // 重置状态，允许下次重新开始时再次淡入
    }
}
```

#### 3. 组合节点（Composite）
**文件：** `UI/Composite/UIElementGroup.cs`  
**行号：** 1-69  
```csharp
// ========== Composite Pattern (Composite) ==========
public class UIElementGroup : IUIComponent
{
    private List<IUIComponent> components = new List<IUIComponent>();
    
    // 第19-23行：添加组件
    public void Add(IUIComponent component)
    
    // 第36-42行：显示所有组件
    public void Show()
    {
        foreach (var component in components)
            component?.Show();
    }
    
    // 第47-53行：隐藏所有组件
    public void Hide()
    {
        foreach (var component in components)
            component?.Hide();
    }
}
```

#### 4. 客户端使用
**文件：** `UI/UI.cs`  
**行号：** 32-163  

**初始化组合（第59-89行）：**
```csharp
private void InitializeCompositeGroups()
{
    // 创建 Tooltip 组合组
    tooltipGroup = new UIElementGroup();
    tooltipGroup.Add(new TooltipComponent(itemToolTip));
    tooltipGroup.Add(new TooltipComponent(statToolTip));
    tooltipGroup.Add(new TooltipComponent(skillToolTip));
    tooltipGroup.Add(new TooltipComponent(craftToolTip));
    
    // 创建死亡界面 UI 元素组
    deathUIGroup = new UIElementGroup();
    endTextComponent = new UIElementComponent(endText);
    restartButtonComponent = new UIElementComponent(restartGameButton);
    deathUIGroup.Add(endTextComponent);
    deathUIGroup.Add(restartButtonComponent);
    
    // 创建淡入淡出组件（第85-89行）
    if (fadeIn != null)
    {
        fadeComponent = new FadeComponent(fadeIn);
    }
}
```

**使用组合（第110-127行）：**
```csharp
public void SwitchTo(GameObject _menu)
{
    // 使用组合模式统一关闭所有 Tooltip
    tooltipGroup?.Hide();  // 一行代码替代原来的4个if判断
    
    // ... 关闭其他子物体，打开目标菜单 ...
    
    // 使用组合模式触发淡入（第125行）
    fadeComponent?.Show();  // 游戏启动时的淡入效果
}
```

**使用组合（第139-148行）：**
```csharp
public void DieFadeOut()
{
    // 使用组合模式触发淡出（第142行）
    fadeComponent?.Hide();  // 玩家死亡时的淡出效果
    
    StartCoroutine(ShowDieText());
}
```

**使用组合（第51-54行）：**
```csharp
void Start()
{
    // 使用组合模式统一隐藏死亡界面 UI
    deathUIGroup?.Hide();  // 确保游戏开始时死亡界面被隐藏
    // ...
}
```

### 模式优势
- **统一接口**：单个元素和元素组使用相同接口
- **简化代码**：
  - 一行 `tooltipGroup?.Hide()` 替代多个 if 判断
  - `fadeComponent?.Show()` 和 `fadeComponent?.Hide()` 封装了淡入淡出逻辑
- **易于扩展**：新增 UI 元素只需实现接口并添加到组中
- **完整封装**：淡入淡出、Tooltip、普通 UI 元素都统一通过组合模式管理

---

## 总结

本次重构实现了**七个设计模式**（包含一个额外模式）：

1. **Service Locator Pattern**（额外模式）- 架构基础
2. **Factory Method Pattern**（创建型）- 敌人状态创建
3. **Observer Pattern**（行为型）- 技能/装备事件系统
4. **Command Pattern**（行为型）- 技能输入封装
5. **Facade Pattern**（结构型）- 服务访问简化
6. **Bridge Pattern**（结构型）- 装备效果分离
7. **Composite Pattern**（结构型）- UI 元素管理

所有模式都已在代码中标注注释，便于理解和维护。

---

**文档生成日期：** 2025-01-XX  
**重构版本：** v2.0


# Unity RPG 游戏重构方案

## 一、项目概述

### 1.1 项目背景
Unity 2D动作RPG游戏，包含玩家系统、敌人AI、技能系统、物品系统、UI系统等模块。

### 1.2 主要架构问题
- **单例模式滥用**：210处使用`.instance.`，导致全局紧耦合
- **代码重复**：敌人状态创建、状态类逻辑重复
- **缺乏抽象**：技能、物品效果缺乏统一接口
- **紧耦合**：系统间直接依赖，难以测试和维护
- **对象池不完善**：频繁创建/销毁对象，性能问题
- **UI系统分散**：缺乏统一管理
- **Manager系统复杂**：接口不统一，难以使用

### 1.3 重构目标
- 应用15+种设计模式，全面解决架构问题
- 降低耦合度，提高可测试性
- 减少代码重复，提高可维护性
- 优化性能，提升可扩展性

---

## 二、设计模式应用方案

### 2.1 创建型模式（5种）

#### 1. 工厂方法模式
**应用场景**：敌人状态创建
**问题**：每个敌人类型（Skeleton、NightBorn、Slime）重复创建状态对象

**重构前代码**：
```csharp
// Enemy_Skeleton.cs - 每个敌人类型都要重复写这些代码
protected override void Awake()
{
    base.Awake();
    
    moveState = new SlimeMoveState(this, stateMachine, "Move", this);
    attackState = new SlimeAttackState(this, stateMachine, "Attack", this);
    deadState = new SlimeDeadState(this, stateMachine, "Die", this);
    battleState = new SlimeBattleState(this, stateMachine, "Move", this);
}
```

**重构后代码**：
```csharp
// 抽象工厂接口
public abstract class EnemyStateFactory
{
    public abstract EnemyState CreateMoveState(Enemy enemy, EnemyStateMachine stateMachine);
    public abstract EnemyState CreateBattleState(Enemy enemy, EnemyStateMachine stateMachine);
    public abstract EnemyState CreateAttackState(Enemy enemy, EnemyStateMachine stateMachine);
    public abstract EnemyState CreateDeadState(Enemy enemy, EnemyStateMachine stateMachine);
}

// 具体工厂实现 - Skeleton
public class SkeletonStateFactory : EnemyStateFactory
{
    public override EnemyState CreateMoveState(Enemy enemy, EnemyStateMachine stateMachine)
    {
        return new SkeletonMoveState(enemy, stateMachine, "Move");
    }
    
    public override EnemyState CreateBattleState(Enemy enemy, EnemyStateMachine stateMachine)
    {
        return new SkeletonBattleState(enemy, stateMachine, "Move");
    }
    
    public override EnemyState CreateAttackState(Enemy enemy, EnemyStateMachine stateMachine)
    {
        return new SkeletonAttackState(enemy, stateMachine, "Attack");
    }
    
    public override EnemyState CreateDeadState(Enemy enemy, EnemyStateMachine stateMachine)
    {
        return new SkeletonDeadState(enemy, stateMachine, "Die");
    }
}

// 使用工厂
public class Enemy_Skeleton : Enemy
{
    private EnemyStateFactory stateFactory;
    
    protected override void Awake()
    {
        base.Awake();
        stateFactory = new SkeletonStateFactory();
        
        // 使用工厂创建状态
        stateMachine.Initialize(stateFactory.CreateMoveState(this, stateMachine));
    }
}
```

**优势**：
- 统一状态创建逻辑，消除重复代码
- 添加新敌人类型只需实现新工厂
- 状态创建逻辑集中管理

#### 2. 抽象工厂模式
**应用场景**：敌人系统创建
**问题**：敌人、状态机、AI创建逻辑分散

**重构后代码**：
```csharp
// 抽象工厂：创建完整的敌人系统
public abstract class EnemySystemFactory
{
    // 创建敌人对象
    public abstract Enemy CreateEnemy();
    
    // 创建状态机
    public abstract EnemyStateMachine CreateStateMachine();
    
    // 创建状态工厂
    public abstract EnemyStateFactory CreateStateFactory();
    
    // 创建AI行为
    public abstract IEnemyAI CreateAI();
}

// 具体工厂：Skeleton系统
public class SkeletonSystemFactory : EnemySystemFactory
{
    public override Enemy CreateEnemy()
    {
        return new Enemy_Skeleton();
    }
    
    public override EnemyStateMachine CreateStateMachine()
    {
        return new EnemyStateMachine();
    }
    
    public override EnemyStateFactory CreateStateFactory()
    {
        return new SkeletonStateFactory();
    }
    
    public override IEnemyAI CreateAI()
    {
        return new SkeletonAI();
    }
}

// 使用抽象工厂
public class EnemySpawner
{
    public Enemy SpawnEnemy(EnemySystemFactory factory)
    {
        Enemy enemy = factory.CreateEnemy();
        EnemyStateMachine stateMachine = factory.CreateStateMachine();
        EnemyStateFactory stateFactory = factory.CreateStateFactory();
        IEnemyAI ai = factory.CreateAI();
        
        // 组装完整的敌人系统
        enemy.Initialize(stateMachine, stateFactory, ai);
        return enemy;
    }
}
```

**优势**：
- 统一创建相关对象族（敌人+状态机+AI）
- 保证创建的对象相互兼容
- 易于切换不同的敌人系统实现

#### 3. 建造者模式
**应用场景**：复杂技能配置
**问题**：技能配置参数多，难以使用

**重构前代码**：
```csharp
// 需要传递大量参数，容易出错
var skill = new FireSkill(10f, 5, 100, true, ElementType.Fire, 2.0f);
```

**重构后代码**：
```csharp
// 技能配置类
public class SkillConfig
{
    public float cooldown;
    public int damage;
    public int manaCost;
    public bool canInterrupt;
    public ElementType elementType;
    public float duration;
}

// 建造者
public class SkillBuilder
{
    private SkillConfig config = new SkillConfig();
    
    public SkillBuilder SetCooldown(float cooldown)
    {
        config.cooldown = cooldown;
        return this; // 返回自身，支持链式调用
    }
    
    public SkillBuilder SetDamage(int damage)
    {
        config.damage = damage;
        return this;
    }
    
    public SkillBuilder SetManaCost(int manaCost)
    {
        config.manaCost = manaCost;
        return this;
    }
    
    public SkillBuilder SetElement(ElementType element)
    {
        config.elementType = element;
        return this;
    }
    
    // 构建技能
    public ISkill Build()
    {
        return new FireSkill(config);
    }
}

// 使用建造者 - 链式调用，清晰易读
var skill = new SkillBuilder()
    .SetCooldown(10f)
    .SetDamage(100)
    .SetManaCost(50)
    .SetElement(ElementType.Fire)
    .Build();
```

**优势**：
- 参数设置清晰，避免参数顺序错误
- 支持可选参数，不需要的参数可以不设置
- 链式调用，代码可读性强

#### 4. 原型模式
**应用场景**：敌人克隆（Slime分裂）
**问题**：手动克隆敌人数据，代码重复

**重构前代码**：
```csharp
// Enemy_Slime.cs - 手动复制所有属性
public void SpawnChildren(Enemy_Slime prefab)
{
    for (int i = 0; i < 2; i++)
    {
        Enemy_Slime child = Instantiate(prefab);
        child.moveSpeed = this.moveSpeed;
        child.attackDistance = this.attackDistance;
        child.experencePoints = this.experencePoints / 2;
        // ... 需要复制很多属性，容易遗漏
    }
}
```

**重构后代码**：
```csharp
// 原型接口
public interface ICloneable<T>
{
    T Clone();
}

// 实现原型模式
public class Enemy_Slime : Enemy, ICloneable<Enemy_Slime>
{
    public Enemy_Slime Clone()
    {
        Enemy_Slime clone = Instantiate(this);
        
        // 深拷贝：复制所有重要数据
        clone.moveSpeed = this.moveSpeed;
        clone.attackDistance = this.attackDistance;
        clone.experencePoints = this.experencePoints / 2;
        clone.enemyStats = this.enemyStats.Clone(); // 状态也要克隆
        
        return clone;
    }
    
    public override void Die()
    {
        if (size == SlimeSize.Large)
        {
            // 使用原型克隆
            Enemy_Slime child1 = mediumPrefab.Clone();
            Enemy_Slime child2 = mediumPrefab.Clone();
            // 设置位置等
        }
    }
}
```

**优势**：
- 封装克隆逻辑，避免手动复制
- 保证克隆的完整性，不会遗漏属性
- 易于维护，修改克隆逻辑只需改一处

#### 5. 单例改进 → 服务定位器模式
**应用场景**：所有Manager系统
**问题**：单例模式滥用，全局紧耦合

**重构前代码**：
```csharp
// 到处都是直接访问单例
public class Player : Entity
{
    void UseSkill()
    {
        SkillManager.instance.dash.UseSkill(); // 直接访问单例
        AudioManager.instance.PlaySFX(1);      // 直接访问单例
        Inventory.instance.AddItem(item);      // 直接访问单例
    }
}
```

**重构后代码**：
```csharp
// 服务定位器
public class ServiceLocator
{
    private static ServiceLocator instance;
    private Dictionary<Type, object> services = new Dictionary<Type, object>();
    
    public static ServiceLocator Instance
    {
        get
        {
            if (instance == null)
                instance = new ServiceLocator();
            return instance;
        }
    }
    
    // 注册服务
    public void Register<T>(T service)
    {
        services[typeof(T)] = service;
    }
    
    // 获取服务
    public T Get<T>()
    {
        if (services.ContainsKey(typeof(T)))
            return (T)services[typeof(T)];
        return default(T);
    }
}

// 初始化时注册服务
public class GameBootstrap : MonoBehaviour
{
    void Awake()
    {
        ServiceLocator.Instance.Register<ISkillManager>(SkillManager.instance);
        ServiceLocator.Instance.Register<IAudioManager>(AudioManager.instance);
        ServiceLocator.Instance.Register<IInventory>(Inventory.instance);
    }
}

// 使用服务定位器
public class Player : Entity
{
    private ISkillManager skillManager;
    private IAudioManager audioManager;
    
    void Start()
    {
        // 通过服务定位器获取服务
        skillManager = ServiceLocator.Instance.Get<ISkillManager>();
        audioManager = ServiceLocator.Instance.Get<IAudioManager>();
    }
    
    void UseSkill()
    {
        skillManager.GetSkill(SkillType.Dash).UseSkill();
        audioManager.PlaySFX(1);
    }
}

// 更好的方式：依赖注入
public class Player : Entity
{
    private ISkillManager skillManager;
    private IAudioManager audioManager;
    
    // 通过构造函数注入依赖
    public Player(ISkillManager skillManager, IAudioManager audioManager)
    {
        this.skillManager = skillManager;
        this.audioManager = audioManager;
    }
}
```

**优势**：
- 解耦：不直接依赖具体类，而是依赖接口
- 可测试：可以注入Mock对象进行单元测试
- 可替换：可以轻松替换服务实现

---

### 2.2 结构型模式（6种）

#### 6. 适配器模式
**应用场景**：统一技能接口
**问题**：不同技能类（Dash_Skill、Sword_Skill等）接口不统一

**重构前代码**：
```csharp
// 不同技能类接口不一致
public class Dash_Skill : Skill
{
    public bool CanUseSkill() { ... }
    public void UseSkill() { ... }
}

public class Sword_Skill : Skill
{
    public bool IsReady() { ... }  // 方法名不同
    public void Activate() { ... } // 方法名不同
}
```

**重构后代码**：
```csharp
// 目标接口：统一的技能接口
public interface ISkill
{
    bool CanUseSkill();
    void UseSkill();
    float GetCooldown();
    float GetCooldownTimer();
}

// 适配器：将现有Skill类适配到ISkill接口
public class SkillAdapter : ISkill
{
    private Skill skill; // 被适配的对象
    
    public SkillAdapter(Skill skill)
    {
        this.skill = skill;
    }
    
    public bool CanUseSkill()
    {
        // 适配不同方法名
        if (skill is Dash_Skill dash)
            return dash.CanUseSkill();
        else if (skill is Sword_Skill sword)
            return sword.IsReady();
        return false;
    }
    
    public void UseSkill()
    {
        if (skill is Dash_Skill dash)
            dash.UseSkill();
        else if (skill is Sword_Skill sword)
            sword.Activate();
    }
    
    public float GetCooldown() => skill.cooldown;
    public float GetCooldownTimer() => skill.cooldownTimer;
}

// 使用适配器统一接口
public class SkillManager
{
    private Dictionary<SkillType, ISkill> skills = new Dictionary<SkillType, ISkill>();
    
    public void RegisterSkill(SkillType type, Skill skill)
    {
        skills[type] = new SkillAdapter(skill); // 用适配器包装
    }
    
    public ISkill GetSkill(SkillType type)
    {
        return skills[type]; // 返回统一接口
    }
}
```

**优势**：
- 统一接口，便于管理
- 不破坏现有代码，通过适配器桥接
- 易于扩展新技能类型

#### 7. 装饰器模式
**应用场景**：技能效果组合
**问题**：效果硬编码在技能类中，难以动态组合

**重构前代码**：
```csharp
// 效果硬编码在技能类中
public class FireSkill : Skill
{
    void ApplyEffect(Entity target)
    {
        // 硬编码：只能应用火焰效果
        target.stats.isIgnited = true;
        // 如果要添加减速效果，需要修改这个类
    }
}
```

**重构后代码**：
```csharp
// 效果接口
public interface IEffect
{
    void Apply(Entity target);
    void Remove(Entity target);
    float GetDuration();
}

// 具体效果
public class FireEffect : IEffect
{
    private float duration;
    private int damage;
    
    public void Apply(Entity target)
    {
        target.stats.isIgnited = true;
        // 应用火焰效果
    }
    
    public void Remove(Entity target)
    {
        target.stats.isIgnited = false;
    }
    
    public float GetDuration() => duration;
}

public class SlowEffect : IEffect
{
    private float slowPercentage;
    
    public void Apply(Entity target)
    {
        target.SlowEntityBy(slowPercentage, GetDuration());
    }
    
    public void Remove(Entity target) { }
    public float GetDuration() => 3f;
}

// 组合效果装饰器：可以组合多个效果
public class CompositeEffect : IEffect
{
    private List<IEffect> effects = new List<IEffect>();
    
    public void AddEffect(IEffect effect)
    {
        effects.Add(effect);
    }
    
    public void Apply(Entity target)
    {
        // 应用所有效果
        foreach (var effect in effects)
        {
            effect.Apply(target);
        }
    }
    
    public void Remove(Entity target)
    {
        foreach (var effect in effects)
        {
            effect.Remove(target);
        }
    }
    
    public float GetDuration()
    {
        return effects.Max(e => e.GetDuration());
    }
}

// 使用装饰器动态组合效果
public class FireSkill : Skill
{
    void UseSkill()
    {
        // 创建组合效果
        CompositeEffect effect = new CompositeEffect();
        effect.AddEffect(new FireEffect());
        effect.AddEffect(new SlowEffect()); // 动态添加减速效果
        
        // 应用到目标
        effect.Apply(target);
    }
}
```

**优势**：
- 效果可以动态组合，灵活扩展
- 每个效果独立，符合单一职责原则
- 不需要修改现有代码就能添加新效果

#### 8. 外观模式
**应用场景**：简化Manager系统
**问题**：多个Manager（SkillManager、Inventory、AudioManager等）接口复杂

**重构前代码**：
```csharp
// 需要了解多个Manager的接口
public class Player : Entity
{
    void UseSkill()
    {
        if (SkillManager.instance.dash.CanUseSkill())
        {
            SkillManager.instance.dash.UseSkill();
            AudioManager.instance.PlaySFX(1);
            Inventory.instance.ConsumeMana(10);
        }
    }
}
```

**重构后代码**：
```csharp
// 外观类：提供统一的简化接口
public class GameFacade
{
    private ISkillManager skillManager;
    private IAudioManager audioManager;
    private IInventory inventory;
    
    public GameFacade(ISkillManager skillManager, IAudioManager audioManager, IInventory inventory)
    {
        this.skillManager = skillManager;
        this.audioManager = audioManager;
        this.inventory = inventory;
    }
    
    // 简化接口：隐藏复杂的子系统交互
    public bool UseSkill(SkillType skillType)
    {
        var skill = skillManager.GetSkill(skillType);
        if (skill != null && skill.CanUseSkill())
        {
            skill.UseSkill();
            audioManager.PlaySFX(GetSkillSFX(skillType));
            inventory.ConsumeMana(skill.GetManaCost());
            return true;
        }
        return false;
    }
    
    private int GetSkillSFX(SkillType type)
    {
        // 映射技能类型到音效
        return type switch
        {
            SkillType.Dash => 1,
            SkillType.Sword => 2,
            _ => 0
        };
    }
}

// 使用外观
public class Player : Entity
{
    private GameFacade gameFacade;
    
    void UseSkill()
    {
        // 只需调用一个简单方法
        gameFacade.UseSkill(SkillType.Dash);
    }
}
```

**优势**：
- 简化接口，隐藏子系统复杂性
- 客户端代码更简洁
- 子系统变化不影响客户端

#### 9. 组合模式
**应用场景**：UI系统层次结构
**问题**：UI组件分散，缺乏统一管理

**重构后代码**：
```csharp
// 组件抽象类
public abstract class UIComponent
{
    protected string name;
    
    public UIComponent(string name)
    {
        this.name = name;
    }
    
    // 统一的操作接口
    public abstract void Render();
    public abstract void Show();
    public abstract void Hide();
    
    // 组合操作（叶子节点不需要实现）
    public virtual void Add(UIComponent component)
    {
        throw new NotImplementedException();
    }
    
    public virtual void Remove(UIComponent component)
    {
        throw new NotImplementedException();
    }
}

// 叶子节点：具体UI组件
public class UIButton : UIComponent
{
    public UIButton(string name) : base(name) { }
    
    public override void Render()
    {
        Debug.Log($"渲染按钮: {name}");
    }
    
    public override void Show() { /* 显示按钮 */ }
    public override void Hide() { /* 隐藏按钮 */ }
}

// 容器节点：可以包含其他组件
public class UIPanel : UIComponent
{
    private List<UIComponent> children = new List<UIComponent>();
    
    public UIPanel(string name) : base(name) { }
    
    public override void Add(UIComponent component)
    {
        children.Add(component);
    }
    
    public override void Remove(UIComponent component)
    {
        children.Remove(component);
    }
    
    public override void Render()
    {
        Debug.Log($"渲染面板: {name}");
        // 递归渲染所有子组件
        foreach (var child in children)
        {
            child.Render();
        }
    }
    
    public override void Show()
    {
        foreach (var child in children)
        {
            child.Show();
        }
    }
    
    public override void Hide()
    {
        foreach (var child in children)
        {
            child.Hide();
        }
    }
}

// 使用组合模式
public class UIManager
{
    private UIComponent root;
    
    void Initialize()
    {
        // 构建UI树
        UIPanel mainPanel = new UIPanel("主面板");
        mainPanel.Add(new UIButton("开始按钮"));
        mainPanel.Add(new UIButton("设置按钮"));
        
        UIPanel subPanel = new UIPanel("子面板");
        subPanel.Add(new UIButton("返回按钮"));
        mainPanel.Add(subPanel);
        
        root = mainPanel;
    }
    
    void ShowUI()
    {
        root.Show(); // 统一操作，自动处理所有子组件
    }
}
```

**优势**：
- 统一处理单个对象和组合对象
- 可以构建任意复杂的UI树结构
- 添加新组件类型很容易

#### 10. 代理模式
**应用场景**：技能冷却控制
**问题**：冷却逻辑分散在各个技能类中

**重构前代码**：
```csharp
// 每个技能类都要自己处理冷却
public class Dash_Skill : Skill
{
    public bool CanUseSkill()
    {
        if (cooldownTimer < 0)
        {
            cooldownTimer = cooldown;
            return true;
        }
        return false;
    }
}
```

**重构后代码**：
```csharp
// 技能接口
public interface ISkill
{
    void UseSkill();
    float GetCooldown();
}

// 真实技能对象
public class Dash_Skill : ISkill
{
    private float cooldown = 5f;
    
    public void UseSkill()
    {
        Debug.Log("使用冲刺技能");
    }
    
    public float GetCooldown() => cooldown;
}

// 代理：控制对真实对象的访问
public class SkillProxy : ISkill
{
    private ISkill realSkill; // 真实技能对象
    private float cooldownTimer;
    private bool isUnlocked;
    
    public SkillProxy(ISkill skill, bool unlocked = true)
    {
        this.realSkill = skill;
        this.isUnlocked = unlocked;
        this.cooldownTimer = 0;
    }
    
    public void UseSkill()
    {
        // 代理控制：检查权限和冷却
        if (!isUnlocked)
        {
            Debug.Log("技能未解锁");
            return;
        }
        
        if (cooldownTimer > 0)
        {
            Debug.Log($"技能冷却中，剩余{cooldownTimer}秒");
            return;
        }
        
        // 通过检查后，调用真实对象
        realSkill.UseSkill();
        cooldownTimer = realSkill.GetCooldown();
    }
    
    public float GetCooldown() => realSkill.GetCooldown();
    
    public void UpdateCooldown(float deltaTime)
    {
        if (cooldownTimer > 0)
            cooldownTimer -= deltaTime;
    }
}

// 使用代理
public class SkillManager
{
    private Dictionary<SkillType, ISkill> skills = new Dictionary<SkillType, ISkill>();
    
    void Initialize()
    {
        // 用代理包装真实技能
        ISkill dashSkill = new Dash_Skill();
        skills[SkillType.Dash] = new SkillProxy(dashSkill, unlocked: true);
    }
    
    void UseSkill(SkillType type)
    {
        if (skills.ContainsKey(type))
        {
            skills[type].UseSkill(); // 通过代理访问，自动处理冷却
        }
    }
}
```

**优势**：
- 统一管理冷却、权限等控制逻辑
- 真实对象不需要关心这些控制逻辑
- 可以动态添加新的控制逻辑（如消耗、条件检查等）

#### 11. 享元模式（可选）
**应用场景**：状态对象共享
**问题**：相同状态对象重复创建

**重构后代码**：
```csharp
// 享元对象：可共享的状态数据
public class EnemyStateFlyweight
{
    public string animBoolName;
    public float defaultDuration;
    // 只包含可共享的数据
}

// 享元工厂：管理共享对象
public class EnemyStateFlyweightFactory
{
    private Dictionary<string, EnemyStateFlyweight> flyweights = new Dictionary<string, EnemyStateFlyweight>();
    
    public EnemyStateFlyweight GetFlyweight(string key)
    {
        if (!flyweights.ContainsKey(key))
        {
            // 创建新的享元对象
            flyweights[key] = new EnemyStateFlyweight
            {
                animBoolName = key,
                defaultDuration = 1f
            };
        }
        return flyweights[key];
    }
}

// 使用享元
public class EnemyState
{
    private EnemyStateFlyweight flyweight; // 共享数据
    private Enemy enemy; // 外部状态（不可共享）
    
    public EnemyState(Enemy enemy, string animName, EnemyStateFlyweightFactory factory)
    {
        this.enemy = enemy;
        this.flyweight = factory.GetFlyweight(animName); // 获取共享对象
    }
    
    public void Enter()
    {
        enemy.anim.SetBool(flyweight.animBoolName, true); // 使用共享数据
    }
}
```

**优势**：
- 减少内存占用，相同状态共享数据
- 适用于大量相似对象的场景

---

### 2.3 行为型模式（8种）

#### 12. 观察者模式
**应用场景**：游戏事件系统
**问题**：系统间直接依赖，耦合度高

**重构前代码**：
```csharp
// 系统间直接调用，紧耦合
public class Player : Entity
{
    void TakeDamage(int damage)
    {
        currentHealth -= damage;
        // 直接调用UI更新
        UI_InGame.instance.UpdateHealthBar(currentHealth);
        // 直接调用音效
        AudioManager.instance.PlaySFX(10);
        // 直接调用成就系统
        AchievementManager.instance.OnPlayerDamaged();
    }
}
```

**重构后代码**：
```csharp
// 事件类型
public enum GameEventType
{
    PlayerDamaged,
    PlayerKilled,
    EnemyKilled,
    SkillUsed,
    ItemPickedUp
}

// 事件数据
public class GameEventData
{
    public GameEventType eventType;
    public object data;
    
    public GameEventData(GameEventType type, object data = null)
    {
        this.eventType = type;
        this.data = data;
    }
}

// 观察者接口
public interface IGameEventListener
{
    void OnEventRaised(GameEventData eventData);
}

// 主题（Subject）：事件管理器
public class EventManager
{
    private static EventManager instance;
    public static EventManager Instance
    {
        get
        {
            if (instance == null)
                instance = new EventManager();
            return instance;
        }
    }
    
    private Dictionary<GameEventType, List<IGameEventListener>> listeners = 
        new Dictionary<GameEventType, List<IGameEventListener>>();
    
    // 订阅事件
    public void Subscribe(GameEventType eventType, IGameEventListener listener)
    {
        if (!listeners.ContainsKey(eventType))
            listeners[eventType] = new List<IGameEventListener>();
        
        listeners[eventType].Add(listener);
    }
    
    // 取消订阅
    public void Unsubscribe(GameEventType eventType, IGameEventListener listener)
    {
        if (listeners.ContainsKey(eventType))
            listeners[eventType].Remove(listener);
    }
    
    // 通知所有观察者
    public void Notify(GameEventType eventType, GameEventData eventData = null)
    {
        if (listeners.ContainsKey(eventType))
        {
            foreach (var listener in listeners[eventType])
            {
                listener.OnEventRaised(eventData ?? new GameEventData(eventType));
            }
        }
    }
}

// 具体观察者：UI系统
public class UI_InGame : MonoBehaviour, IGameEventListener
{
    void Start()
    {
        // 订阅事件
        EventManager.Instance.Subscribe(GameEventType.PlayerDamaged, this);
    }
    
    public void OnEventRaised(GameEventData eventData)
    {
        if (eventData.eventType == GameEventType.PlayerDamaged)
        {
            UpdateHealthBar(); // 响应事件
        }
    }
}

// 使用观察者模式
public class Player : Entity
{
    void TakeDamage(int damage)
    {
        currentHealth -= damage;
        // 发布事件，不直接调用其他系统
        EventManager.Instance.Notify(GameEventType.PlayerDamaged, 
            new GameEventData(GameEventType.PlayerDamaged, currentHealth));
    }
}
```

**优势**：
- 解耦：发布者和订阅者互不直接依赖
- 灵活：可以动态添加/移除观察者
- 易于扩展：添加新的事件类型和观察者很容易

#### 13. 策略模式
**应用场景**：伤害计算系统
**问题**：物理伤害、魔法伤害、元素伤害计算逻辑分散

**重构前代码**：
```csharp
// 伤害计算逻辑分散，难以维护
public class CharacterStats
{
    public int CalculateDamage(CharacterStats defender, DamageType type)
    {
        if (type == DamageType.Physical)
        {
            return damage.GetValue() - defender.armor.GetValue();
        }
        else if (type == DamageType.Magical)
        {
            return magicDamage.GetValue() - defender.magicResistance.GetValue();
        }
        // 添加新伤害类型需要修改这个方法
    }
}
```

**重构后代码**：
```csharp
// 策略接口
public interface IDamageCalculationStrategy
{
    int CalculateDamage(CharacterStats attacker, CharacterStats defender, DamageInfo info);
}

// 具体策略：物理伤害
public class PhysicalDamageStrategy : IDamageCalculationStrategy
{
    public int CalculateDamage(CharacterStats attacker, CharacterStats defender, DamageInfo info)
    {
        int baseDamage = attacker.damage.GetValue();
        int armor = defender.armor.GetValue();
        int finalDamage = Mathf.Max(1, baseDamage - armor);
        
        // 暴击计算
        if (Random.value < attacker.critChance.GetValue() / 100f)
        {
            finalDamage = (int)(finalDamage * attacker.critPower.GetValue() / 100f);
        }
        
        return finalDamage;
    }
}

// 具体策略：魔法伤害
public class MagicalDamageStrategy : IDamageCalculationStrategy
{
    public int CalculateDamage(CharacterStats attacker, CharacterStats defender, DamageInfo info)
    {
        int baseDamage = attacker.magicDamage.GetValue();
        int resistance = defender.magicResistance.GetValue();
        return Mathf.Max(1, baseDamage - resistance);
    }
}

// 具体策略：元素伤害
public class ElementalDamageStrategy : IDamageCalculationStrategy
{
    public int CalculateDamage(CharacterStats attacker, CharacterStats defender, DamageInfo info)
    {
        int elementDamage = info.elementType switch
        {
            ElementType.Fire => attacker.fireDamage.GetValue(),
            ElementType.Ice => attacker.iceDamage.GetValue(),
            ElementType.Lightning => attacker.lightningDamage.GetValue(),
            _ => 0
        };
        
        return elementDamage; // 元素伤害通常无视防御
    }
}

// 上下文：伤害计算器
public class DamageCalculator
{
    private IDamageCalculationStrategy strategy;
    
    public void SetStrategy(IDamageCalculationStrategy strategy)
    {
        this.strategy = strategy;
    }
    
    public int Calculate(CharacterStats attacker, CharacterStats defender, DamageInfo info)
    {
        // 根据伤害类型选择策略
        switch (info.damageType)
        {
            case DamageType.Physical:
                SetStrategy(new PhysicalDamageStrategy());
                break;
            case DamageType.Magical:
                SetStrategy(new MagicalDamageStrategy());
                break;
            case DamageType.Elemental:
                SetStrategy(new ElementalDamageStrategy());
                break;
        }
        
        return strategy.CalculateDamage(attacker, defender, info);
    }
}

// 使用策略模式
public class CharacterStats
{
    private DamageCalculator damageCalculator = new DamageCalculator();
    
    public int DoDamage(CharacterStats defender, DamageInfo info)
    {
        return damageCalculator.Calculate(this, defender, info);
    }
}
```

**优势**：
- 算法封装：每种伤害计算算法独立封装
- 易于扩展：添加新伤害类型只需实现新策略
- 易于测试：可以单独测试每种策略

#### 14. 命令模式
**应用场景**：技能/物品使用
**问题**：使用逻辑直接调用，无法撤销、记录

**重构前代码**：
```csharp
// 直接调用，无法撤销
public class Player : Entity
{
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Q))
        {
            skill.dash.UseSkill(); // 直接调用
        }
    }
}
```

**重构后代码**：
```csharp
// 命令接口
public interface ICommand
{
    void Execute();
    void Undo();
    bool CanExecute();
}

// 具体命令：使用技能
public class UseSkillCommand : ICommand
{
    private ISkill skill;
    private Entity caster;
    private bool wasExecuted = false;
    
    public UseSkillCommand(ISkill skill, Entity caster)
    {
        this.skill = skill;
        this.caster = caster;
    }
    
    public bool CanExecute()
    {
        return skill.CanUseSkill();
    }
    
    public void Execute()
    {
        if (CanExecute())
        {
            skill.UseSkill();
            wasExecuted = true;
        }
    }
    
    public void Undo()
    {
        if (wasExecuted)
        {
            // 撤销技能效果（如果可能）
            // 例如：恢复冷却时间、撤销伤害等
            Debug.Log("撤销技能使用");
        }
    }
}

// 命令管理器
public class CommandManager
{
    private Stack<ICommand> commandHistory = new Stack<ICommand>();
    private Queue<ICommand> commandQueue = new Queue<ICommand>();
    
    public void ExecuteCommand(ICommand command)
    {
        if (command.CanExecute())
        {
            command.Execute();
            commandHistory.Push(command); // 记录历史
        }
    }
    
    public void UndoLastCommand()
    {
        if (commandHistory.Count > 0)
        {
            ICommand lastCommand = commandHistory.Pop();
            lastCommand.Undo();
        }
    }
    
    public void QueueCommand(ICommand command)
    {
        commandQueue.Enqueue(command);
    }
    
    public void ProcessQueue()
    {
        while (commandQueue.Count > 0)
        {
            ICommand command = commandQueue.Dequeue();
            ExecuteCommand(command);
        }
    }
}

// 使用命令模式
public class Player : Entity
{
    private CommandManager commandManager = new CommandManager();
    
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Q))
        {
            // 创建命令并执行
            ICommand command = new UseSkillCommand(skill.dash, this);
            commandManager.ExecuteCommand(command);
        }
        
        if (Input.GetKeyDown(KeyCode.Z))
        {
            // 撤销上一个命令
            commandManager.UndoLastCommand();
        }
    }
}
```

**优势**：
- 支持撤销/重做功能
- 可以将命令放入队列，延迟执行
- 可以记录命令历史，用于回放、调试

#### 15. 模板方法模式
**应用场景**：状态类基类
**问题**：PlayerState和EnemyState有大量重复逻辑

**重构前代码**：
```csharp
// PlayerState和EnemyState有大量重复代码
public class PlayerState
{
    public virtual void Enter()
    {
        player.anim.SetBool(animBoolName, true);
        rb = player.rb;
        triggerCalled = false;
        // 每个状态都要写这些代码
    }
}

public class EnemyState
{
    public virtual void Enter()
    {
        enemyBase.anim.SetBool(animBoolName, true);
        rb = enemyBase.rb;
        triggerCalled = false;
        // 重复的代码
    }
}
```

**重构后代码**：
```csharp
// 模板方法基类
public abstract class BaseState
{
    protected string animBoolName;
    protected bool triggerCalled;
    protected Rigidbody2D rb;
    protected float stateTimer;
    
    // 模板方法：定义算法骨架
    public void Enter()
    {
        OnEnter();           // 钩子方法1
        Initialize();        // 抽象方法
        StartAnimation();    // 钩子方法2
        ResetTimer();        // 具体方法
    }
    
    public void Update()
    {
        stateTimer -= Time.deltaTime;
        OnUpdate();          // 钩子方法
    }
    
    public void Exit()
    {
        StopAnimation();     // 钩子方法
        OnExit();            // 抽象方法
    }
    
    // 抽象方法：子类必须实现
    protected abstract void Initialize();
    protected abstract void OnExit();
    
    // 钩子方法：子类可以重写
    protected virtual void OnEnter() { }
    protected virtual void OnUpdate() { }
    protected virtual void StartAnimation() 
    {
        GetAnimator().SetBool(animBoolName, true);
    }
    protected virtual void StopAnimation()
    {
        GetAnimator().SetBool(animBoolName, false);
    }
    
    // 具体方法
    protected void ResetTimer()
    {
        triggerCalled = false;
        stateTimer = 0;
    }
    
    // 抽象方法：获取动画器
    protected abstract Animator GetAnimator();
    protected abstract Rigidbody2D GetRigidbody();
}

// 具体实现：PlayerState
public class PlayerIdleState : BaseState
{
    private Player player;
    
    public PlayerIdleState(Player player, PlayerStateMachine stateMachine, string animBoolName)
    {
        this.player = player;
        this.animBoolName = animBoolName;
    }
    
    protected override void Initialize()
    {
        rb = player.rb;
    }
    
    protected override void OnExit() { }
    
    protected override Animator GetAnimator() => player.anim;
    protected override Rigidbody2D GetRigidbody() => player.rb;
    
    protected override void OnUpdate()
    {
        // 具体状态逻辑
        if (Input.GetAxisRaw("Horizontal") != 0)
        {
            // 切换到移动状态
        }
    }
}

// 具体实现：EnemyState
public class EnemyIdleState : BaseState
{
    private Enemy enemy;
    
    protected override void Initialize()
    {
        rb = enemy.rb;
    }
    
    protected override void OnExit() { }
    
    protected override Animator GetAnimator() => enemy.anim;
    protected override Rigidbody2D GetRigidbody() => enemy.rb;
}
```

**优势**：
- 消除重复代码，公共逻辑在基类
- 算法骨架固定，细节由子类实现
- 易于维护，修改模板方法影响所有子类

#### 16. 中介者模式
**应用场景**：UI组件通信
**问题**：UI组件间直接通信，耦合度高

**重构前代码**：
```csharp
// UI组件间直接通信
public class UI_HealthBar : MonoBehaviour
{
    void UpdateHealth(int health)
    {
        // 直接调用其他UI组件
        UI_InGame.instance.UpdateHealthText(health);
        UI_StatSlot.instance.UpdateStat();
    }
}
```

**重构后代码**：
```csharp
// 中介者接口
public interface IUIMediator
{
    void Notify(UIComponent sender, string eventName, object data);
    void Register(UIComponent component);
}

// 具体中介者
public class UIMediator : IUIMediator
{
    private Dictionary<string, List<UIComponent>> components = 
        new Dictionary<string, List<UIComponent>>();
    
    public void Register(UIComponent component)
    {
        string componentType = component.GetType().Name;
        if (!components.ContainsKey(componentType))
            components[componentType] = new List<UIComponent>();
        components[componentType].Add(component);
    }
    
    public void Notify(UIComponent sender, string eventName, object data)
    {
        // 根据事件类型通知相关组件
        switch (eventName)
        {
            case "HealthChanged":
                // 通知所有需要响应生命值变化的组件
                NotifyComponents("UI_HealthBar", "OnHealthChanged", data);
                NotifyComponents("UI_StatSlot", "OnHealthChanged", data);
                break;
            case "SkillUsed":
                NotifyComponents("UI_SkillTree", "OnSkillUsed", data);
                break;
        }
    }
    
    private void NotifyComponents(string componentType, string method, object data)
    {
        if (components.ContainsKey(componentType))
        {
            foreach (var component in components[componentType])
            {
                component.ReceiveNotification(method, data);
            }
        }
    }
}

// UI组件基类
public abstract class UIComponent : MonoBehaviour
{
    protected IUIMediator mediator;
    
    public void SetMediator(IUIMediator mediator)
    {
        this.mediator = mediator;
        mediator.Register(this);
    }
    
    protected void SendNotification(string eventName, object data)
    {
        mediator?.Notify(this, eventName, data);
    }
    
    public abstract void ReceiveNotification(string method, object data);
}

// 具体组件
public class UI_HealthBar : UIComponent
{
    public void UpdateHealth(int health)
    {
        // 更新自己的显示
        UpdateBar(health);
        
        // 通过中介者通知其他组件
        SendNotification("HealthChanged", health);
    }
    
    public override void ReceiveNotification(string method, object data)
    {
        if (method == "OnHealthChanged")
        {
            // 响应其他组件的通知
        }
    }
}
```

**优势**：
- 解耦：组件不直接通信，通过中介者
- 易于维护：通信逻辑集中在中介者
- 易于扩展：添加新组件只需注册到中介者

#### 17. 备忘录模式
**应用场景**：游戏状态保存/恢复
**问题**：保存逻辑分散，难以实现撤销

**重构后代码**：
```csharp
// 备忘录：保存游戏状态
public class GameMemento
{
    public PlayerState PlayerState { get; set; }
    public InventoryState InventoryState { get; set; }
    public SkillState SkillState { get; set; }
    public DateTime SaveTime { get; set; }
    
    public GameMemento(PlayerState playerState, InventoryState inventoryState, SkillState skillState)
    {
        this.PlayerState = playerState;
        this.InventoryState = inventoryState;
        this.SkillState = skillState;
        this.SaveTime = DateTime.Now;
    }
}

// 原发器：需要保存状态的对象
public class GameState
{
    private PlayerState playerState;
    private InventoryState inventoryState;
    private SkillState skillState;
    
    // 创建备忘录
    public GameMemento CreateMemento()
    {
        return new GameMemento(
            playerState.Clone(),
            inventoryState.Clone(),
            skillState.Clone()
        );
    }
    
    // 恢复状态
    public void RestoreMemento(GameMemento memento)
    {
        this.playerState = memento.PlayerState;
        this.inventoryState = memento.InventoryState;
        this.skillState = memento.SkillState;
    }
}

// 管理者：管理备忘录
public class GameStateCaretaker
{
    private Stack<GameMemento> history = new Stack<GameMemento>();
    private const int MAX_HISTORY = 10;
    
    public void SaveState(GameMemento memento)
    {
        history.Push(memento);
        
        // 限制历史记录数量
        if (history.Count > MAX_HISTORY)
        {
            var temp = new Stack<GameMemento>();
            for (int i = 0; i < MAX_HISTORY; i++)
            {
                temp.Push(history.Pop());
            }
            history = temp;
        }
    }
    
    public GameMemento RestoreState()
    {
        if (history.Count > 0)
        {
            return history.Pop();
        }
        return null;
    }
    
    public bool CanRestore()
    {
        return history.Count > 0;
    }
}

// 使用备忘录模式
public class SaveManager
{
    private GameStateCaretaker caretaker = new GameStateCaretaker();
    private GameState gameState;
    
    public void SaveGame()
    {
        GameMemento memento = gameState.CreateMemento();
        caretaker.SaveState(memento);
    }
    
    public void LoadGame()
    {
        if (caretaker.CanRestore())
        {
            GameMemento memento = caretaker.RestoreState();
            gameState.RestoreMemento(memento);
        }
    }
}
```

**优势**：
- 封装状态保存逻辑
- 支持撤销/恢复功能
- 不破坏对象封装性

#### 18. 访问者模式
**应用场景**：游戏对象遍历操作
**问题**：难以对游戏对象进行统一操作

**重构后代码**：
```csharp
// 访问者接口
public interface IGameObjectVisitor
{
    void Visit(Enemy enemy);
    void Visit(Player player);
    void Visit(Item item);
    void Visit(Chest chest);
}

// 可访问对象接口
public interface IGameObjectVisitable
{
    void Accept(IGameObjectVisitor visitor);
}

// 具体访问者：伤害所有敌人
public class DamageAllEnemiesVisitor : IGameObjectVisitor
{
    private int damage;
    
    public DamageAllEnemiesVisitor(int damage)
    {
        this.damage = damage;
    }
    
    public void Visit(Enemy enemy)
    {
        enemy.TakeDamage(damage); // 对敌人造成伤害
    }
    
    public void Visit(Player player)
    {
        // 玩家不受影响
    }
    
    public void Visit(Item item)
    {
        // 物品不受影响
    }
    
    public void Visit(Chest chest)
    {
        // 宝箱不受影响
    }
}

// 具体访问者：收集所有物品
public class CollectItemsVisitor : IGameObjectVisitor
{
    private List<Item> collectedItems = new List<Item>();
    
    public void Visit(Enemy enemy) { }
    public void Visit(Player player) { }
    
    public void Visit(Item item)
    {
        collectedItems.Add(item);
        item.PickUp();
    }
    
    public void Visit(Chest chest) { }
    
    public List<Item> GetCollectedItems() => collectedItems;
}

// 具体对象实现访问接口
public class Enemy : Entity, IGameObjectVisitable
{
    public void Accept(IGameObjectVisitor visitor)
    {
        visitor.Visit(this);
    }
}

public class Item : MonoBehaviour, IGameObjectVisitable
{
    public void Accept(IGameObjectVisitor visitor)
    {
        visitor.Visit(this);
    }
}

// 使用访问者模式
public class GameWorld
{
    private List<IGameObjectVisitable> gameObjects = new List<IGameObjectVisitable>();
    
    public void ApplyVisitor(IGameObjectVisitor visitor)
    {
        foreach (var obj in gameObjects)
        {
            obj.Accept(visitor); // 每个对象接受访问者
        }
    }
    
    // 使用示例
    public void DamageAllEnemies(int damage)
    {
        DamageAllEnemiesVisitor visitor = new DamageAllEnemiesVisitor(damage);
        ApplyVisitor(visitor);
    }
}
```

**优势**：
- 将操作与对象结构分离
- 易于添加新操作（新访问者）
- 集中相关操作

#### 19. 迭代器模式
**应用场景**：集合遍历（敌人列表等）
**问题**：集合遍历方式不统一

**重构后代码**：
```csharp
// 迭代器接口
public interface IIterator<T>
{
    bool HasNext();
    T Next();
    void Reset();
}

// 具体迭代器：敌人集合迭代器
public class EnemyIterator : IIterator<Enemy>
{
    private List<Enemy> enemies;
    private int currentIndex = 0;
    
    public EnemyIterator(List<Enemy> enemies)
    {
        this.enemies = enemies;
    }
    
    public bool HasNext()
    {
        return currentIndex < enemies.Count;
    }
    
    public Enemy Next()
    {
        if (HasNext())
        {
            return enemies[currentIndex++];
        }
        return null;
    }
    
    public void Reset()
    {
        currentIndex = 0;
    }
}

// 可迭代集合接口
public interface IIterable<T>
{
    IIterator<T> GetIterator();
}

// 具体集合：敌人管理器
public class EnemyManager : IIterable<Enemy>
{
    private List<Enemy> enemies = new List<Enemy>();
    
    public void AddEnemy(Enemy enemy)
    {
        enemies.Add(enemy);
    }
    
    public IIterator<Enemy> GetIterator()
    {
        return new EnemyIterator(enemies);
    }
    
    // C# 也支持 foreach（实现 IEnumerable）
    public IEnumerator<Enemy> GetEnumerator()
    {
        return enemies.GetEnumerator();
    }
}

// 使用迭代器
public class GameManager
{
    private EnemyManager enemyManager = new EnemyManager();
    
    void UpdateAllEnemies()
    {
        // 方式1：使用迭代器
        IIterator<Enemy> iterator = enemyManager.GetIterator();
        while (iterator.HasNext())
        {
            Enemy enemy = iterator.Next();
            enemy.Update();
        }
        
        // 方式2：使用 foreach（C# 内置支持）
        foreach (Enemy enemy in enemyManager)
        {
            enemy.Update();
        }
    }
}
```

**优势**：
- 统一遍历接口
- 隐藏集合内部实现
- 支持多种遍历方式

---

### 2.4 架构模式（3种）

#### 20. 依赖注入
**应用场景**：解耦系统依赖
**问题**：所有类直接访问单例，无法测试

**重构后代码**：
```csharp
// 依赖注入容器
public class DIContainer
{
    private Dictionary<Type, object> instances = new Dictionary<Type, object>();
    private Dictionary<Type, Func<object>> factories = new Dictionary<Type, Func<object>>();
    
    // 注册单例
    public void RegisterSingleton<T>(T instance)
    {
        instances[typeof(T)] = instance;
    }
    
    // 注册工厂
    public void RegisterFactory<T>(Func<T> factory)
    {
        factories[typeof(T)] = () => factory();
    }
    
    // 解析依赖
    public T Resolve<T>()
    {
        Type type = typeof(T);
        
        // 先查找单例
        if (instances.ContainsKey(type))
        {
            return (T)instances[type];
        }
        
        // 再查找工厂
        if (factories.ContainsKey(type))
        {
            return (T)factories[type]();
        }
        
        // 尝试自动创建（需要无参构造函数）
        return Activator.CreateInstance<T>();
    }
}

// 使用依赖注入
public class Player : Entity
{
    private ISkillManager skillManager;
    private IEventManager eventManager;
    private IAudioManager audioManager;
    
    // 构造函数注入
    public Player(ISkillManager skillManager, IEventManager eventManager, IAudioManager audioManager)
    {
        this.skillManager = skillManager;
        this.eventManager = eventManager;
        this.audioManager = audioManager;
    }
}

// 初始化容器
public class GameBootstrap : MonoBehaviour
{
    private DIContainer container = new DIContainer();
    
    void Awake()
    {
        // 注册服务
        container.RegisterSingleton<ISkillManager>(SkillManager.instance);
        container.RegisterSingleton<IEventManager>(EventManager.Instance);
        container.RegisterSingleton<IAudioManager>(AudioManager.instance);
        
        // 注册工厂
        container.RegisterFactory<Player>(() => 
        {
            return new Player(
                container.Resolve<ISkillManager>(),
                container.Resolve<IEventManager>(),
                container.Resolve<IAudioManager>()
            );
        });
        
        // 创建Player（自动注入依赖）
        Player player = container.Resolve<Player>();
    }
}
```

**优势**：
- 解耦：不直接依赖具体类
- 可测试：可以注入Mock对象
- 可维护：依赖关系清晰

#### 21. 服务定位器
**应用场景**：改进单例模式
**问题**：单例模式滥用

**代码示例**（已在模式5中详细说明，这里补充使用示例）：

```csharp
// 服务定位器（见模式5）
// 使用示例
public class Player : Entity
{
    void Start()
    {
        // 通过服务定位器获取服务
        var skillManager = ServiceLocator.Instance.Get<ISkillManager>();
        var audioManager = ServiceLocator.Instance.Get<IAudioManager>();
        
        // 使用服务
        skillManager.GetSkill(SkillType.Dash).UseSkill();
    }
}
```

**优势**：
- 统一服务管理
- 易于替换实现
- 支持服务注册和查找

#### 22. 对象池模式
**应用场景**：性能优化
**问题**：频繁创建/销毁对象，GC压力大

**重构前代码**：
```csharp
// 频繁创建/销毁对象
public class SkillEffect : MonoBehaviour
{
    void CreateEffect()
    {
        GameObject effect = Instantiate(effectPrefab); // 创建
        // 使用效果
        Destroy(effect, 2f); // 销毁
    }
}
```

**重构后代码**：
```csharp
// 对象池接口
public interface IPoolable
{
    void OnGetFromPool();
    void OnReturnToPool();
}

// 通用对象池
public class ObjectPool<T> where T : MonoBehaviour, IPoolable
{
    private Queue<T> pool = new Queue<T>();
    private T prefab;
    private Transform parent;
    private int maxSize;
    
    public ObjectPool(T prefab, Transform parent, int initialSize = 10, int maxSize = 50)
    {
        this.prefab = prefab;
        this.parent = parent;
        this.maxSize = maxSize;
        
        // 预创建对象
        for (int i = 0; i < initialSize; i++)
        {
            T obj = CreateNew();
            Return(obj);
        }
    }
    
    private T CreateNew()
    {
        T obj = Object.Instantiate(prefab, parent);
        obj.gameObject.SetActive(false);
        return obj;
    }
    
    // 从池中获取对象
    public T Get()
    {
        T obj;
        
        if (pool.Count > 0)
        {
            obj = pool.Dequeue();
        }
        else
        {
            obj = CreateNew();
        }
        
        obj.gameObject.SetActive(true);
        obj.OnGetFromPool(); // 通知对象被取出
        return obj;
    }
    
    // 归还对象到池
    public void Return(T obj)
    {
        if (pool.Count >= maxSize)
        {
            Object.Destroy(obj.gameObject);
            return;
        }
        
        obj.gameObject.SetActive(false);
        obj.OnReturnToPool(); // 通知对象被归还
        pool.Enqueue(obj);
    }
}

// 实现IPoolable接口
public class SkillEffect : MonoBehaviour, IPoolable
{
    public void OnGetFromPool()
    {
        // 重置状态
        transform.position = Vector3.zero;
    }
    
    public void OnReturnToPool()
    {
        // 清理状态
    }
}

// 使用对象池
public class SkillManager : MonoBehaviour
{
    private ObjectPool<SkillEffect> effectPool;
    
    void Start()
    {
        effectPool = new ObjectPool<SkillEffect>(
            effectPrefab, 
            transform, 
            initialSize: 10, 
            maxSize: 50
        );
    }
    
    void CreateEffect()
    {
        // 从池中获取，而不是创建新对象
        SkillEffect effect = effectPool.Get();
        
        // 使用效果
        StartCoroutine(ReturnAfterDelay(effect, 2f));
    }
    
    IEnumerator ReturnAfterDelay(SkillEffect effect, float delay)
    {
        yield return new WaitForSeconds(delay);
        effectPool.Return(effect); // 归还到池，而不是销毁
    }
}
```

**优势**：
- 减少对象创建/销毁，降低GC压力
- 提高性能，特别是频繁使用的对象
- 可以控制对象数量，避免内存溢出

---

## 三、架构设计

### 3.1 架构层次

```
应用层 (Player, Enemy, UI)
    ↓
服务层 (ServiceLocator, DIContainer, ObjectPool)
    ↓
核心层 (EventManager, CommandManager, DamageCalculator, GameFacade等)
    ↓
业务层 (Entity, Skill, Item, UI)
```

### 3.2 目录结构

```
refactored_src/
├── Core/                    # 核心系统
│   ├── DependencyInjection/ # 依赖注入
│   ├── Events/              # 观察者模式
│   ├── Commands/             # 命令模式
│   ├── Damage/               # 策略模式
│   ├── Facade/               # 外观模式
│   ├── Memento/              # 备忘录模式
│   ├── Visitor/              # 访问者模式
│   └── ObjectPool/           # 对象池
├── Entity/
│   ├── Enemy/
│   │   ├── Factories/        # 工厂方法+抽象工厂
│   │   ├── States/
│   │   │   └── BaseState.cs  # 模板方法模式
│   │   └── Prototype/        # 原型模式
├── Skills/
│   ├── ISkill.cs             # 适配器模式
│   ├── SkillAdapter.cs
│   ├── SkillProxy.cs          # 代理模式
│   ├── Effects/               # 装饰器模式
│   └── Builders/              # 建造者模式
├── Items/
│   └── Effects/               # 装饰器模式
└── UI/
    ├── Components/            # 组合模式
    └── Mediator/              # 中介者模式
```

---

## 四、重构计划

### 阶段1：核心架构（必须）
1. 依赖注入 + 服务定位器（解决单例滥用）
2. 观察者模式（事件系统）
3. 策略模式（伤害计算）
4. 命令模式（技能使用）
5. 外观模式（简化Manager）

### 阶段2：实体系统
6. 工厂方法模式（敌人状态）
7. 抽象工厂模式（敌人系统）
8. 模板方法模式（状态基类）
9. 原型模式（敌人克隆）

### 阶段3：技能系统
10. 适配器模式（统一技能接口）
11. 装饰器模式（技能效果）
12. 代理模式（技能冷却）
13. 建造者模式（技能配置）

### 阶段4：UI系统
14. 组合模式（UI层次）
15. 中介者模式（UI通信）

### 阶段5：高级功能
16. 备忘录模式（状态保存）
17. 访问者模式（对象遍历）
18. 迭代器模式（集合遍历）
19. 对象池模式（性能优化）

---

## 五、代码标记规范

在重构的代码中添加注释标记：

```csharp
// ========== Refactored with XXX Pattern ==========
// 说明重构的内容和原因
// 原代码位置：XXX.cs
// 重构日期：2025-XX-XX
// ============================================================
```

---

## 六、预期收益

### 代码质量
- **代码重复减少**：约50%
- **耦合度**：从高度耦合到低耦合
- **可测试性**：支持单元测试（依赖注入）
- **可维护性**：清晰的架构和职责分离

### 性能
- **GC压力降低**：对象池减少对象创建
- **内存优化**：享元模式共享状态对象

### 可扩展性
- **易于添加新功能**：通过工厂、策略等模式
- **易于替换实现**：通过接口和依赖注入
- **易于配置**：通过建造者模式

---

## 七、风险控制

1. **渐进式重构**：分阶段进行，每阶段完成后测试
2. **保留原代码**：`original_src/`作为参考
3. **充分测试**：每个模式应用后测试
4. **性能监控**：对比重构前后性能

---

## 八、设计模式选择说明

### 最低要求（6种）
- 工厂方法模式：解决状态创建重复
- 适配器模式：统一技能接口
- 装饰器模式：灵活组合效果
- 观察者模式：解耦系统通信
- 策略模式：灵活计算伤害
- 命令模式：支持撤销等功能

### 全面方案（15+种）
在最低要求基础上，增加：
- 抽象工厂、建造者、原型：完善创建型模式
- 外观、组合、代理、享元：完善结构型模式
- 模板方法、中介者、备忘录、访问者、迭代器：完善行为型模式
- 依赖注入、服务定位器、对象池：架构模式

---
